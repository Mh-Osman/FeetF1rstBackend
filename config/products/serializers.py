# your_app_name/serializers.py
from rest_framework import serializers
from .models import Product, ProductVariant

class ProductVariantSerializer(serializers.ModelSerializer):
    """
    Serializer for the ProductVariant model.
    Includes the actual price calculation.
    """
    effective_price = serializers.DecimalField(max_digits=10, decimal_places=2, read_only=True)

    class Meta:
        model = ProductVariant
        fields = ['id', 'size', 'color', 'stock', 'price_override', 'effective_price', 'sku', 'image', 'created_at', 'updated_at']
        read_only_fields = ['created_at', 'updated_at', 'sku'] # SKU might be generated by a system, not user input directly for existing items

    def create(self, validated_data):
        # If SKU is meant to be auto-generated upon creation and not provided by user
        if 'sku' not in validated_data or not validated_data['sku']:
            # Example: Generate a simple SKU if not provided
            product_name_slug = validated_data['product'].name_en.replace(" ", "-").lower()[:20]
            size_slug = validated_data.get('size', 'NOSIZE').replace(" ", "-").lower()[:10]
            color_slug = validated_data.get('color', 'NOCOLOR').replace(" ", "-").lower()[:10]
            # Ensure unique SKU, possibly add a timestamp or random string
            validated_data['sku'] = f"{product_name_slug}-{size_slug}-{color_slug}-{ProductVariant.objects.count() + 1}"
        return super().create(validated_data)

    def to_representation(self, instance):
        """
        Adds the effective_price to the representation of the variant.
        """
        representation = super().to_representation(instance)
        representation['effective_price'] = instance.get_price()
        # Optionally, you might want to show the full image URL
        if instance.image:
            request = self.context.get('request')
            if request is not None:
                representation['image'] = request.build_absolute_uri(instance.image.url)
        return representation


class ProductSerializer(serializers.ModelSerializer):
    """
    Serializer for the Product model, including its variants.
    """
    # Use ProductVariantSerializer to nest variants within the product
    variants = ProductVariantSerializer(many=True, read_only=True)
    # Add a writable nested serializer for creating/updating variants directly with the product
    # This requires careful handling in the create/update methods of the ProductSerializer
    # For simplicity, we'll keep variants read_only here and manage them separately or in a custom way.
    # If you want to create/update variants nested, you'd need to implement create/update methods here.

    class Meta:
        model = Product
        fields = [
            'id', 'category',
            'name_en', 'description_en',
            'name_it', 'description_it',
            'name_de', 'description_de',
            'price', 'is_active',
            'created_at', 'updated_at',
            'variants' # Include the nested variants
        ]
        read_only_fields = ['created_at', 'updated_at']